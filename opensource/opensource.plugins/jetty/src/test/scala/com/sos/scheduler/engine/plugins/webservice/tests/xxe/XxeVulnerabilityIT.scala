package com.sos.scheduler.engine.plugins.webservice.tests.xxe

import com.sos.scheduler.engine.common.scalautil.FileUtils.implicits._
import com.sos.scheduler.engine.common.utils.FreeTcpPortFinder.findRandomFreeTcpPort
import com.sos.scheduler.engine.kernel.scheduler.SchedulerException
import com.sos.scheduler.engine.kernel.settings.CppSettingName.htmlDir
import com.sos.scheduler.engine.plugins.jetty.test.JettyPluginJerseyTester
import com.sos.scheduler.engine.plugins.webservice.tests.xxe.XxeVulnerabilityIT._
import com.sos.scheduler.engine.test.configuration.TestConfiguration
import com.sos.scheduler.engine.test.scalatest.ScalaSchedulerTest
import com.sun.jersey.api.client.Client
import java.net.URI
import javax.ws.rs.core.MediaType.TEXT_XML_TYPE
import org.junit.runner.RunWith
import org.scalatest.FreeSpec
import org.scalatest.Matchers._
import org.scalatest.junit.JUnitRunner

@RunWith(classOf[JUnitRunner])
final class XxeVulnerabilityIT extends FreeSpec with ScalaSchedulerTest with JettyPluginJerseyTester {

  private lazy val webDirectory = testDirectory / "config"
  private lazy val dtdFilename = "test.dtd"  // Suffix .xml, because only .xml resources are copied
  private lazy val dtdContent = (webDirectory / dtdFilename).contentString
  private lazy val cppPort = findRandomFreeTcpPort()

  override protected lazy val testConfiguration = TestConfiguration(
    getClass,
    mainArguments = List(s"-tcp-port=$cppPort"),
    cppSettings = Map(htmlDir → webDirectory.toString)
  )

  "Jetty" - {
    lazy val dtdUri = webResource.getUriBuilder.path(s"jobscheduler/$dtdFilename").build()

    "DTD is accessible" in {
      info(s"$dtdUri")
      assertResult(dtdContent) { get[String](s"jobscheduler/$dtdFilename") }
      assertResult(dtdContent) { webResource.uri(dtdUri).get(classOf[String]) }
    }

    addExecuteXmlTest(dtdUri)

    "XXE vulnerability via Jetty HTTP" in {
      assertResult(dtdContent) { get[String]("jobscheduler/test.dtd") }
      val responseXml = controller.suppressingTerminateOnError {
        webResource.path("/jobscheduler/engine/command").`type`(TEXT_XML_TYPE).post(classOf[String], evilCommand(dtdUri))
      }
      responseXml.replace("&quot;", "\"") should include (ExpectedErrorMessage)
      responseXml should include ("org.xml.sax.SAXParseException")
      responseXml should include ("Z-JAVA-105")
    }
  }

  "C++ web server" - {
    lazy val cppWebResource = {
      val cppWebClient = Client.create()
      onClose { cppWebClient.destroy() }
      cppWebClient.resource(s"http://127.0.0.1:$cppPort/")
    }
    lazy val dtdUri = cppWebResource.getUriBuilder.path(dtdFilename).build()

    "DTD is accessible" in {
      info(s"$dtdUri")
      assertResult(dtdContent) { cppWebResource.uri(dtdUri).get(classOf[String]) }
    }

    addExecuteXmlTest(dtdUri)

    "XXE vulnerability via HTTP" in {
      cppWebResource.path("/test.dtd").get(classOf[String]) shouldEqual dtdContent
      controller.suppressingTerminateOnError {
        val response = cppWebResource.path("/").post(classOf[String], evilCommand(dtdUri))
        response.replace("&quot;", "\"") should (include("<ERROR") and include(ExpectedErrorMessage))
      }
    }
  }

  private def addExecuteXmlTest(dtdUri: ⇒ URI): Unit = {
    "XXE vulnerability via executeXml" in {
      intercept[SchedulerException] {
        controller.suppressingTerminateOnError {
          scheduler executeXml evilCommand(dtdUri)
        }
      }.getMessage should include(ExpectedErrorMessage)
    }
  }

  private def evilCommand(dtdUri: URI) =
   s"""<?xml version="1.0"?>
      |<!DOCTYPE test [
      |  <!ENTITY % one SYSTEM "$dtdUri">
      |    %one;
      |    %two;
      |    %four;
      |  ]>
    """.stripMargin
}

private object XxeVulnerabilityIT {
  private val ExpectedErrorMessage =
    """DOCTYPE is disallowed when the feature "http://apache.org/xml/features/disallow-doctype-decl" set to true"""
}
